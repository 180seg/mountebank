<%
title = 'proxies'
description = 'Using mountebank to record and playback through proxying to a real network dependency'
%>

<% include ../../_header %>

<h1>Proxies</h1>

<p>Proxies are one of the most powerful features of mountebank, rivaled only by the
mighty <a href='/docs/api/injection'>injection.</a>  Proxies support record/replay
behavior to easily capture a rich set of test data for your test scenarios.
Each proxy definition allows you to define the the fields which should be included
in newly created <code>predicates</code>.</p>

<p><code>proxy</code> response types take the following parameters:</p>

<table>
  <tr>
    <th>Parameter</th>
    <th style='min-width: 4em;'>Default</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>to</code></td>
    <td>required</td>
    <td>A URL without the path (e.g. http://someserver:3000 or tcp://someserver:3000)</td>
    <td>Defines the origin server that the request should proxy to.</td>
  </tr>
  <tr>
    <td><code>mode</code></td>
    <td><code>proxyOnce</code></td>
    <td>string, one of <code>proxyOnce</code> or <code>proxyAlways</code>.</td>
    <td>Defines the replay behavior of the proxy. See <a href='#modes'>below</a> for details.
        <ul class='bullet-list'>
            <li><code>proxyOnce</code> - ensures that the same request (defined
                by the predicates) is never proxied twice. mountebank only records
                one response for each request, and automatically replays that response the next
                time the request predicates match.</li>
            <li><code>proxyAlways</code> - All calls will be proxied, allowing multiple responses
                to be saved for the same logical request. You have to explicitly tell mountebank
                to replay those responses.</li>
        </ul>
        <p class='info-icon'>Use the <a href='/docs/commandLine#replay'><code>mb replay</code></a>
            command to automatically remove the proxies, switching from record mode to replay mode.</p>
    </td>
  </tr>
  <tr>
    <td><code>predicateGenerators</code></td>
    <td><code>[]</code></td>
    <td>array</td>
    <td>An array of objects that defines how the predicates for new stubs are created. Each object in
    the array defines the fields to generate predicates from. See <a href='#predicateGenerators'>below</a>
    for examples.</td>
  </tr>
  <tr>
    <td><code>injectHeaders</code></td>
    <td><code>{}</code></td>
    <td>object</td>
    <td>Key-value pairs of headers to inject into the proxied <i>request</i>.  This is useful when the behavior of
    the system being proxied can be altered with appropriate headers (e.g. pointing REST links back to mountebank
    for further proxying). You can also use this to pass along an 'Accept-Encoding: identity' header to prevent
    the proxy from sending back compressed data. Existing headers will be overwritten if they match the injected headers.</td>
  </tr>
  <tr>
    <td><code>addWaitBehavior</code></td>
    <td><code>false</code></td>
    <td>boolean</td>
    <td>If true, mountebank will add a <a href='/docs/api/behaviors#behavior-wait'><code>wait</code></a>
    behavior to the response with the same latency that the proxied call took. This is useful in load
    testing scenarios where you want to simulate the actual latency of downstream services that you're
    virtualizing.</td>
  </tr>
  <tr>
    <td><code>addDecorateBehavior</code></td>
    <td><code>null</code></td>
    <td>string, JavaScript</td>
    <td>If defined, mountebank will add a <a href='/docs/api/behaviors#behavior-decorate'><code>decorate</code></a>
    behavior to the response.</td>
  </tr>
</table>

<p>http and https proxies add three additional optional parameters for situations where the
origin server expects to use mutual authentication and will request a client certificate:</p>

<table>
  <tr>
    <th>Parameter</th>
    <th style='min-width: 4em;'>Default</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>cert</code></td>
    <td><code>null</code></td>
    <td>A PEM-formatted string</td>
    <td>The SSL client certificate</td>
  </tr>
  <tr>
    <td><code>key</code></td>
    <td><code>null</code></td>
    <td>A PEM-formatted string</td>
    <td>The SSL client private key</td>
  </tr>
  <tr>
    <td><code>ciphers</code></td>
    <td><code>ALL</code></td>
    <td>A valid cipher (see <a href='http://openssl.cs.utah.edu/docs/apps/ciphers.html'>this page</a> for formats)</td>
    <td>For older (and insecure) https servers, this field allows you to override the cipher used to commuicate</td>
  </tr>
</table>

<p>It is occasionally useful to capture how long the original proxied request takes.  mountebank
stores the number of milliseconds for the request in the <code>_proxyResponseTime</code> field in the
response.</p>

<p class='info-icon'>Note, if you use a corporate proxy, then the standard shell
<code>http_proxy</code> or <code>https_proxy</code> environment variables will be honored.</p>

<h2 id='modes'>Understanding proxy modes</h2>

<p>The <code>mode</code> defines the behavior of the <code>proxy</code>. The default
<code>proxyOnce</code> mode is simpler; it always creates a new stub in front of the stub with
the proxy response, relying on mountebank's first-match policy to automatically replay the saved
response in the new stub the next time a request matches the predicates. Imagine the following
<code>stubs</code> array, set by us when we create the imposter:</p>

<testScenario name='modes'>
    <step type='http'>
<code class='hidden'>POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 2001,
  "protocol": "http"
}</code>
    </step>

    <step type='http'>
<pre><code><div class='hidden'>POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 2000,
  "protocol": "http",
</div>"stubs": [{
  "responses": [{
    "proxy": {
      "to": "<change to='http://localhost:2001'>http://origin-server.com</change>",
      "mode": "proxyOnce",
      "predicateGenerators": [{ "matches": { "path": true } }]
    }
  }]
}]<div class='hidden'>
}</div>
</code></pre></step>

<p>When we issue an HTTP call to <code>/test</code>, the stub will proxy all of the request
details to http://origin-server.com/test, and save off the response in a new stub in front of the
stub with the <code>proxy</code> response:</p>

    <step type='http'>
<code class='hidden'>GET /test HTTP/1.1
Host: localhost:2000</code>
    </step>

    <step type='http'>
<code class='hidden''>DELETE /imposters/2001 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json</code>
    </step>

    <step type='http'>
<code class='hidden'>DELETE /imposters/2000 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json</code>

        <assertResponse>
<pre><code><div class='hidden'>HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Content-Type: application/json; charset=utf-8
Content-Length: <volatile>2112</volatile>
Date: <volatile>Thu, 11 May 2017 03:02:02 GMT</volatile>
Connection: keep-alive

{
  "protocol": "http",
  "port": 2000,
  "numberOfRequests": 1,
  "requests": [
    {
      "requestFrom": "<volatile>::ffff:127.0.0.1:61075</volatile>",
      "method": "GET",
      "path": "/test",
      "query": {},
      "headers": {
        "accept": "application/json",
        "Host": "localhost:2000",
        "Connection": "keep-alive"
      },
      "body": "",
      "timestamp": "<volatile>2017-05-11T02:27:41.725Z</volatile>"
    }
  ],</div>
"stubs": [
  <strong class='highlight1'>{
    "predicates": [{ "deepEquals": { "path": "/test" } } ],
    "responses": [{
      "is": {
        "statusCode": 200,
        "headers": {
          "Connection": "close",
          "Date": "<volatile>Thu, 11 May 2017 03:02:02 GMT</volatile>",
          "Transfer-Encoding": "chunked"
        },
        "body": "",
        "_mode": "text",
        "_proxyResponseTime": <volatile>9</volatile>
      }
    }]
  }</strong>,
  {
    "responses": [
      {
        "proxy": {
          "to": "http://localhost:2001",
          "mode": "proxyOnce",
          "predicateGenerators": [{ "matches": { "path": true } }]
        }
      }
    ]<div class='hidden'>,
      "matches": [
        {
          "timestamp": "<volatile>2017-05-11T03:02:02.945Z</volatile>",
          "request": {
            "requestFrom": "<volatile>::ffff:127.0.0.1:61227</volatile>",
            "method": "GET",
            "path": "/test",
            "query": {},
            "headers": {
              "accept": "application/json",
              "Host": "localhost:2000",
              "Connection": "keep-alive"
            },
            "body": ""
          },
          "response": {
            "statusCode": 200,
            "headers": {
              "Connection": "close",
              "Date": "<volatile>Thu, 11 May 2017 03:02:02 GMT</volatile>",
              "Transfer-Encoding": "chunked"
            },
            "body": "",
            "_mode": "text"
          }
        }
      ]
    }</div>
  ]<div class='hidden'>,
  "_links": {
    "self": { "href": "http://localhost:<%= port %>/imposters/2000" }
  }
}</div>
</code></pre>
        </assertResponse>
    </step>
</testScenario>

<p>We'll look at how the predicate gets generated shortly. What's important to note
at this point is that, because of mountebank's first-match policy on stubs, the next
time the imposter receives a request to <code>/test</code>, the saved predicates on the
newly created stub will match, and the recorded response will be replayed.  If
the imposter receives a call to <code>/different-path</code>, then it will proxy again,
creating a new stub, because the <code>path</code> is different.</p>

<p>The <code>proxyAlways</code> mode saves stubs <em>behind</em> the <code>proxy</code>
stub.  This allows you to record a richer set of interactions with the origin server,
but requires you to save off the imposter representation and remove or reorder the
<code>proxy</code> stubs to replay those interactions. The easiest way to do that is with
the <a href='/docs/commandLine#replay'><code>mb replay</code></a> command.</p>

<p>Let's say you had the following <code>stubs</code> array:</p>

<pre><code>
"stubs": [
  {
    "responses": [
      {
        "proxy": {
          "to": "http://origin-server.com",
          "mode": "proxyAlways",
          "predicateGenerators": [{ "matches": { "path": true } }]
        }
      }
    ]
  },
  {
    "predicates": [{ "equals": { "path": "/test" } }],
    "responses": [{ "is": { "body": "first response" } }]
  }
]
</code></pre>

<p>Every time we send a request to <code>/test</code>, it will
be proxied to http://origin-server.com/test.  Since a predicate matching a <code>path</code>
of <code>/test</code> already exists on another stub, the proxied response is added to the
existing stub's <code>responses</code> array.</p>

<pre><code>
"stubs": [
  {
    "responses": [
      {
        "proxy": {
          "to": "http://origin-server.com",
          "mode": "proxyAlways",
          "predicateGenerators": [{ "matches": { "path": true } }]
        }
      }
    ]
  },
  {
    "predicates": [{ "equals": { "path": "/test" } }],
    "responses": [
      { "is": { "body": "first response" } },
      <strong class='highlight1'>{ "is": { ...saved response } }</strong>
    ]
  }
]
</code></pre>

<p>If no existing stub's predicates matched the request, a new stub will be created at the
end of the <code>stubs</code> array.</p>

<h2 id='predicateGenerators'>Understanding predicateGenerators</h2>

<p>Recording a rich set of test data through proxying requires also capturing the
appropriate predicates from the request, so that saved responses are only replayed
when the requests are similar. The <code>predicateGenerators</code> field defines the
template for the generated predicates. Each object in the <code>predicateGenerators</code>
array takes the following fields:</p>

<table>
  <tr>
    <th>Parameter</th>
    <th style='min-width: 4em;'>Default</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>matches</code></td>
    <td><code>{}</code></td>
    <td>object</td>
    <td>The fields that need to be equal in subsequent requests to replay the saved response.
    Set the field value <code>true</code> to generate a predicate based on it. Nested fields,
    as in JSON fields or HTTP headers, are supported as well, as long as the leaf keys have
    a <code>true</code> value.</td>
  </tr>
  <tr>
    <td><code>caseSensitive</code></td>
    <td><code>false</code></td>
    <td>boolean</td>
    <td>Determines if the match is case sensitive or not.  This includes keys for objects
    such as query parameters.</td>
  </tr>
  <tr>
    <td><code>except</code>/td>
    <td><code>""</code></td>
    <td>string</td>
    <td>Defines a regular expression that is stripped out of the request field
    before matching.</td>
  </tr>
  <tr>
    <td><code>xpath</code></td>
    <td><code>null</code></td>
    <td>object</td>
    <td>Defines an object containing a <code>selector</code> string and, optionally, an
    <code>ns</code> object field that defines a namespace map. The predicate's
    scope is limited to the selected value in the request field.</td>
  </tr>
  <tr>
    <td><code>jsonpath</code></td>
    <td><code>null</code></td>
    <td>object</td>
    <td>Defines an object containing a <code>selector</code> string. The predicate's
    scope is limited to the selected value in the request field.</td>
  </tr>
</table>

<p>With the exception of <code>matches</code>, the fields correspond to the standard
<a href='/docs/api/predicates'>predicate parameters</a>. Each object in the
<code>predicateGenerators</code> array generates an object in
the newly created stub's <code>predicates</code> array. You can decide how strictly
you want the generated predicates to match object fields. The following example
matches the root <code>query</code> field:</p>

<pre><code>
"stubs": [{
  "responses": [{
    "proxy": {
      "to": "http://origin-server.com",
      "mode": "proxyOnce",
      <strong class='highlight1'>"predicateGenerators": [{
        "matches": { "query": true },
        "caseSensitive": true
      }]</strong>
    }
  }]
}]
</code></pre>

<p>This will generate a <code>deepEquals</code> predicate at the same level, which requires
that all keys and values in the querystring match (although the order can be different).
We added the <code>caseSensitive</code> parameter, which will also require the cases of the
query keys and values to match. If the incoming request is to <code>/test?q=mountebank&page=1</code>,
the following stub will be generating:</p>

<pre><code>
"stubs": [
  {
    <strong class='highlight1'>"predicates": [{
      "deepEquals": {
        "query": {
          "q": "mountebank",
          "page": "1"
        }
      },
      "caseSensitive": true
    }]</strong>,
    "responses": [{ "is": { ...saved response } }]
  },
  {
    "responses": [{
      "proxy": {
        "to": "http://origin-server.com",
        "mode": "proxyOnce",
        "predicateGenerators": [{
          "matches": { "query": true },
          "caseSensitive": true
        }]
      }
    }]
  }
]
</code></pre>

<p>We could have also specified only the query key we cared about:</p>

<pre><code>
"stubs": [{
  "responses": [{
    "proxy": {
      "to": "http://origin-server.com",
      "mode": "proxyOnce",
      predicateGenerators": [{
        "matches": {
          <strong class='highlight1'>"query": { "q": "mountebank" }</strong>
        }
      }]
    }
  }]
}]
</code></pre>

<p>The <a href='/docs/api/xpath'><code>xpath</code></a> and
<a href='/docs/api/jsonpath'><code>jsonpath</code></a> predicate parameters work
by limiting the scope of the generated predicate to the matching value in the
proxied request. If the selector matches multiple values in the proxied request,
they will all be part of the generated predicate, using standard predicate
<a href='docs/api/predicates#array-match'>array matching rules</a>. For example,
imagine a request reaching the following stub with an XML body of
"&lt;doc&gt;&lt;number&gt;1&lt;/number&gt;&lt;number&gt;2&lt;/number&gt;&lt;number&gt;3&lt;/number&gt;&lt;/doc&gt;"
</p>

<pre><code>
"stubs": [{
  "responses": [{
    "proxy": {
      "to": "http://origin-server.com",
      "mode": "proxyOnce",
      <strong class='highlight1'>"predicateGenerators": [{
        "matches": { "body": true },
        "xpath": { "selector": "//number" }
      }]</strong>
    }
  }]
}]
</code></pre>

<p>Rather than matching the entire body, the generated predicate will require all three
values matching the xpath selector in the original proxied request to be present (in any
order):</p>

<pre><code>
"stubs": [
  {
    <strong class='highlight1'>"predicates": [{
      "deepEquals": { "body": ["1", "2", "3"] },
      "xpath": { "selector": "//number" }
    }]</strong>,
    "responses": [{ "is": { ...saved response } }]
  },
  {
    "responses": [{
      "proxy": {
        "to": "http://origin-server.com",
        "mode": "proxyOnce",
        "predicateGenerators": [{
          "matches": { "body": true },
          "xpath": { "selector": "//number" }
        }]
      }
    }]
  }
]
</code></pre>

<h2>Examples</h2>

<p>Our examples will proxy to the following origin server.  To help
us keep track of the imposters in the logs, we'll set the <code>name</code>
field.  We're using <a href='/docs/api/injection'>injection</a> to return the
number of times the proxy has been called to the user.</p>

<pre><code data-test-id='proxy example'
           data-test-step='1'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 7575,
  "protocol": "http",
  "name": "origin",
  "stubs": [
    {
      "responses": [{
        "inject": "function (request, state) { state.calls = state.calls || 0; return { body: 'call ' + ++state.calls }; }"
      }]
    }
  ]
}
</code></pre>

<p>Select the behavior of the proxy below for a relevant example:</p>

<section class="accordion">
  <div>
    <input id='proxy-once' name='proxy-once' type="checkbox" />
    <label for='proxy-once'>proxyOnce</label>
    <section>
      <% include proxy/proxyOnce %>
    </section>
  </div>
  <div>
    <input id='proxy-always' name='proxy-always' type="checkbox" />
    <label for='proxy-always'>proxyAlways</label>
    <section>
      <% include proxy/proxyAlways %>
    </section>
  </div>
  <div>
    <input id='proxy-inject-headers' name='proxy-inject-headers' type="checkbox" />
    <label for='proxy-inject-headers'>injectHeaders</label>
    <section>
      <% include proxy/injectHeaders %>
    </section>
  </div>
</section>

<% include ../../_footer %>
