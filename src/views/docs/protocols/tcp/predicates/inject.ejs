<p>The <code>inject</code> predicate allows you to inject JavaScript to determine if
the predicate should match or not.  The JavaScript should be a function that accepts
the request parameter (and optionally a logger)  and returns truthy or falsy.
mountebank doesn't really know what that means, so he always returns <code>true</code>
or <code>false</code> when he uses <code>inject</code>.</p>

<p>Unlike all the other predicates, <code>inject</code> can work against the entire
request object (see the example below).  There are three important considerations for
injection.  First, it will only work if you've run <code>mb</code> with the
<code>--allowInjection</code> flag.  Second, when you create an imposter, mountebank
dry runs all predicates looking for validation errors.  This means that your JavaScript
will run once before the imposter is even created.  Lastly, predicate injection must be
strictly synchronous.</p>

<p>The execution will have access to a node.js environment.  The example below uses node's
<code>util</code> module to format a log message and send to the logger (technically
redundant since the logger already does that).  The logger has four methods corresponding
to the log levels: <code>debug</code>, <code>info</code>, <code>warn</code>, and
<code>error</code>.  During the dry run, only the <code>error</code> level will
write to the log.</p>

<pre><code data-test-id='tcp inject example'
           data-test-step='1'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 4555,
  "protocol": "tcp",
  "mode": "text",
  "stubs": [<strong class='highlight1'>
    {
      "responses": [{ "is": { "data": "first response" } }],
      "predicates": {
        "data": {
          "inject": "function (data, logger) { var util = require('util'); logger.info(util.format('data is %s', data)); return data === 'first\n'; }"
        }
      }
    }</strong>,<strong class='highlight2'>
    {
      "responses": [{ "is": { "data": "second response" } }],
      "predicates": {
        "request": {
          "inject": "function (request) { return request.requestFrom.indexOf('localhost') === 0 && request.data === 'second\n'; }"
        }
      }
    }</strong>
  ]
}
</code></pre>

<p>The first request matches on the data.  Note that, because our injected JavaScript
is case-sensitive, so is the predicate, unlike a typical text-mode <code>is</code> predicate.</p>

<pre><code data-test-id='tcp inject example'
           data-test-step='2'
           data-test-type='exec'>
echo '<strong class='highlight1'>first</strong>' | nc localhost 4555
</code></pre>

<pre><code data-test-id='tcp inject example'
           data-test-verify-step='2'>
<strong class='highlight1'>first response</strong>
</code></pre>

<p>The logs will also show the injected log output.  The second predicate has to
match a request originating from localhost with the case-sensitive data match:</p>

<pre><code data-test-id='tcp inject example'
           data-test-step='3'
           data-test-type='exec'>
echo '<strong class='highlight1'>second</strong>' | nc localhost 4555
</code></pre>

<p>...giving the response:</p>

<pre><code data-test-id='tcp inject example'
           data-test-verify-step='3'>
second response
</code></pre>

<code class='hidden' data-test-id='tcp inject example'
                     data-test-step='4  '
                     data-test-type='http'>
DELETE /imposters/4555 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
</code>
