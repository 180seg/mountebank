<% include ../../_header %>

<h1>http / https</h1>

<p>mountebank employs world-class HTTP and HTTPS imposters.  The stubbing capability
is second to none.  Let's look at a simple request:</p>

<pre><code>
  POST /imposters HTTP/1.1
  Host: localhost:2525
  Accept: application/json
  Content-Type: application/json

  {
    "port": 2526,
    "protocol": "http",
    "stubs": [{
      "responses": [
        { "is": { "statusCode": 400 }}
      ],
      "predicates": {
        "path": { "is": "/test" },
        "method": { "is": "POST" },
        "body": { "not": { "contains": "requiredField" } },
        "headers": {
          "Content-Type": { "is": "application/json" }
        }
      }
    }]
  }
</code></pre>

<p>An imposter can be created with an array of <em>stubs</em>, each of which contains
an array of at least one <em>response</em> and, optionally, <em>predicates</em>.
After the initial <code>POST</code>, when you retrieve an imposter back from mountebank
(via a <code>GET /imposters</code>, <code>GET /imposters/2526</code>, or
<code>DELETE /imposters/2526</code>), the response body will show a record of all stub
interactions to help you troubleshoot the stub predicates and responses in a
<em>matches</em> field:</p>

<pre><code>
HTTP/1.1 200 OK
Content-Type: application/json

{
  "protocol": "http",
  "port": 2526,
  "requests": [
    {
      "path": "/test",
      "method": "GET",
      "headers": {
        "host": "localhost:2526",
      },
      "body": ""
    },
    {
      "path": "/test",
      "method": "POST",
      "headers": {
        "host": "localhost:2526",
        "content-type": "application/json",
        "content-length": "28"
      },
      "body": "{\"optionalField\": \"present\"}"
    }
  ],
  "stubs": [
    {
      "responses": [
        {
          "is": {
            "statusCode": 400
          }
        }
      ],
      "predicates": {
        "path": {
          "is": "/test"
        },
        "query": {
          "exists": { "q": true }
        },
        "method": {
          "is": "POST"
        },
        "body": {
          "not": {
            "contains": "requiredField"
          }
        },
        "headers": {
          "Content-Type": {
            "is": "application/json"
          }
        }
      },
      "matches": [
        {
          "timestamp": "2013-12-06T02:21:43.162Z",
          "request": {
            "path": "/test?q=value",
            "method": "POST",
            "headers": {
              "host": "localhost:2526",
              "content-type": "application/json",
              "content-length": "28"
            },
            "body": "{\"optionalField\": \"present\"}"
          },
          "response": {
            "statusCode": 400,
            "headers": {
              "connection": "close"
            },
            "body": ""
          }
        }
      ]
    }
  ],
  "_links": {
    "self": {
      "href": "http://localhost:2525/imposters/2526"
    }
  }
}
</code></pre>

<h2>Predicates</h2>

<p>Predicates define whether a stub matches a request or not.  In the absence of a predicate,
the stub always matches.  When multiple stubs are created on an imposter, the first stub that
matches is selected.  All predicates are based on the following request fields:</p>

<table>
    <tr>
        <th>Field</th>
        <th>Description</th>
        <th>Type</th>
        <th>Example</th>
    </tr>
    <tr>
        <td><code>path</code></td>
        <td>The path of the request, without the querystring</td>
        <td>string</td>
        <td>/resource</td>
    </tr>
    <tr>
        <td><code>query</code></td>
        <td>The querystring of the request</td>
        <td>object</td>
        <td>{ "q": "value" }</td>
    </tr>
    <tr>
        <td><code>method</code></td>
        <td>The request method</td>
        <td>string</td>
        <td>GET</td>
    </tr>
    <tr>
        <td><code>headers</code></td>
        <td>The HTTP headers</td>
        <td>object</td>
        <td><code>{ "Accept": "application/json" }</code></td>
    </tr>
    <tr>
        <td><code>body</code></td>
        <td>The request body</td>
        <td>string</td>
        <td>'{ "port": 2526 }'</td>
    </tr>
</table>

<p>Each predicate object contains one or more of the request fields as keys.  All keys are
AND'd together.  The following predicate operators are allowed:</p>

<table>
    <tr>
        <th>Operator</th>
        <th>Example</th>
    </tr>
    <tr>
        <td><code>is</code></td>
        <td><code>"headers": { "X-Key": { "is": "Value" } }</code></td>
    </tr>
    <tr>
        <td><code>contains</code></td>
        <td><code>"body": { "contains": "message" }</code></td>
    </tr>
    <tr>
        <td><code>startsWith</code></td>
        <td><code>"path": { "startsWith": "/resource/123" }</code></td>
    </tr>
    <tr>
        <td><code>endsWith</code></td>
        <td><code>"body": { "endsWith": "message" }</code></td>
    </tr>
    <tr>
        <td><code>matches</code></td>
        <td><code>"body": { "matches": "^start.+end$" }</code></td>
    </tr>
    <tr>
        <td><code>exists</code></td>
        <td><code>"query": { "first": { "exists": true, "is": "1" } }</code></td>
    </tr>
    <tr>
        <td><code>not</code></td>
        <td><code>"body": { "not": { "contains": "message" } }</code></td>
    </tr>
    <tr>
        <td><code>inject</code></td>
        <td><code>{ "request": { "inject": "function (request) { return request.path === '/test'; }" } }</code></td>
    </tr>
</table>

<p>Most of the predicate are self-explanatory.  All the string operations are case-insensitive (this
includes the header keys).  The <code>matches</code> operator is a JavaScript regular expression.
The <code>exists</code> operator is satisfied if the header or query key is present, when true, or when missing,
when false.  When <code>exists</code> is used on a string field, like <code>body</code>, and is true,
it is satisfied when the body is non-empty.</p>

<p><code>inject</code> is the most powerful operator, but it only works when <code>mb</code> is run
with the <code>--allowInjection</code> flag.  Like the other operators, it works against the standard
request fields of <code>path</code>, <code>method</code>, <code>headers</code>, and <code>body</code>.
If called against one of those fields, the <code>inject</code> value is a function whose single
parameter is that field.  Unlike the other operators, <code>inject</code> can take an entire request
object, which can use all four fields to make a decision.  The function returns true or false.</p>

<h2>Responses</h2>

<p>Every HTTP and HTTPS response from an imposter consists of the following fields:</p>

<table>
  <tr>
    <th>Field</th>
    <th>Type</th>
    <th>Example</th>
    <th>Default</th>
  </tr>
  <tr>
    <td><code>statusCode</code></td>
    <td>int, corresponding to a valid <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html'>
      status code</a></td>
    <td>400</td>
    <td>200</td>
  </tr>
  <tr>
    <td><code>headers</code></td>
    <td>object</td>
    <td><pre><code>
      {
        "Location": "http://localhost:2526/resource",
        "Content-Type": "application/json"
      }
    </code></pre></td>
    <td><code>{ "Connection": "close" }</code></td>
  </tr>
  <tr>
    <td><code>body</code></td>
    <td>string</td>
    <td><code>{"errors": []}</code></td>
    <td>''</td>
  </tr>
</table>

<p>It doesn't make sense to create an empty array of responses, but each response is under no
obligation to override the defaults.  In the example above, the response only overrides the
<code>statusCode</code>, and will default to <code>{ "Connection": "close" }</code> for the
<code>headers</code> and an empty <code>body</code>.  mountebank HTTP and HTTPS <em>always</em>
refuse to allow keepalive connections, even when you try and specify one in your response.
The problem is that they wreak havoc with automated tests if you send a <code>DELETE</code>
to an imposter.  mountebank will no longer be listening on that socket, but the system
under test will reuse the existing TCP connection.  mountebank has found that this
causes difficult to track down bugs when multiple tests are run.</p>

<p>The responses array defines a circular buffer.  Every time the stub matches the request,
the first response is pulled from the front of the responses array, evaluated, and pushed
to the back of the array.  This elegantly does what you want.  In the common case, when you
always want to return the same response (as in the example above), you simply add one
response.  More complex scenarios will require that the same endpoint returns a sequence of
different responses for the same predicates.  Simply add them all to the array in order.
When the sequence finishes, it will start over.  More complexity can be added by simply
adding more responses to the array, without complicating the contract.</p>

<p>The example above showed an <code>is</code> response, which is the simplest of all
response types.  The following response resolvers are supported:</p>

<table>
  <tr>
    <th>Resolver</th>
    <th>Description</th>
    <th>Example</th>
  </tr>
  <tr>
    <td><code>is</code></td>
    <td>Merges the specified response fields with the defaults.</td>
    <td><code>{ "is": { "statusCode": 400 }}</code></td>
  </tr>
  <tr>
    <td><code>proxy</code></td>
    <td>Proxies the request to the specified URL and returns the response.</td>
    <td><code>{ "proxy": "http://real.api.com" }</code></td>
  </tr>
  <tr>
    <td><code>proxyOnce</code></td>
    <td>The first time the response is used, it will proxy to the specified
      URL and return the response, just like <code>proxy</code>, but it will
      also save the response as an <code>is</code> response for all future
      matches.</td>
      <td><code>{ "proxyOnce": "http://real.api.com" }</code></td>
  </tr>
  <tr>
    <td><code>inject</code></td>
    <td>Allows you to inject a JavaScript function to create the response object.
      The function will be passed three parameters: the request object, an initially
      empty JavaScript object for saving state between <code>inject</code> responses
      on the same imposter (even if they come from different stubs), and a callback
      for asynchronous operations (see below).  <em><code>inject</code> responses only
      work if <code>mb</code> is run with <code>--allowInjection</code></em>.</td>
    <td><code>
        { "inject": "function (request, state) {" +
                    "    if (!state.calls) { state.calls = 0; }\n" +
                    "    state.calls += 1;\n" +
                    "    return { body: state.calls.toString() };\n" +
                    "}" }
    </code></td>
  </tr>
</table>

<h3>Proxies</h3>

<p>mountebank recommends that you only use the <code>proxy</code> as the last stub
in the <code>stubs</code> array.  This would allow you to set up specific stubs
for the endpoints you are interested in faking out, and rely on a <code>proxy</code>
response to delegate all other endpoints to the real dependency.  This takes advantage
of the imposter's <em>first match</em> policy on stubs, which is based on the order you
set the stubs up in the <code>stubs</code> array.</p>

<p>The <code>proxyOnce</code> resolver is a great way to seed tests.  After setting an imposter
up with a <code>proxyOnce</code> stub and exercising the system under test, you can
<code>GET</code> the imposter.  On subsequent test runs, simply load the same representation
you received during the <code>GET</code> when you <code>POST /imposters</code>, and it will
automatically fall back to the saved <code>is</code> response. If you don't want to send some
of the saved state of the last imposter, you can delete elements like <code>matches</code>
and <code>_links</code>.</p>

<p>For example, let's say we create the <code>proxyOnce</code> resolver listed above and
want to reuse the saved state for subsequent test runs:</p>

<pre><code>
    GET /imposters/2526 HTTP/1.1
    Host: localhost:2525
    Accept: application/json


    HTTP/1.1 200 OK
    Content-Type: application/json

    {
      "protocol": "http",
      "port": 2526,
      "requests": [
        {
          "path": "/",
          "method": "GET",
          "headers": {
            "accept": "application/json",
            "host": "localhost:2526",
            "connection": "close"
          },
          "body": ""
        }
      ],
      "stubs": [
        {
          "responses": [
            {
              "proxyOnce": "http://real.api.com/",
              "is": {
                "statusCode": 200,
                "headers": {
                  "connection": "close",
                  "date": "Sat, 07 Dec 2013 20:19:51 GMT",
                  "transfer-encoding": "chunked"
                },
                "body": "PROXIED"
              }
            }
          ],
          "matches": [
            {
              "timestamp": "2013-12-07T19:39:43.527Z",
              "request": {
                "path": "/",
                "method": "GET",
                "headers": {
                  "accept": "application/json",
                  "host": "localhost:2526",
                  "connection": "close"
                },
                "body": ""
              },
              "response": {
                "statusCode": 200,
                "headers": {
                  "connection": "close"
                },
                "body": "PROXIED"
              }
            }
          ]
        }
      ],
      "_links": {
        "self": {
          "href": "http://localhost:2525/imposters/2526"
        }
      }
    }
</code></pre>

<p>Save off the response body.  The next time you need to set up the test, you can simply
reload it.  If you want to clean up the JSON and only send the relevant attributes,
remove the <code>requests</code>, <code>matches</code>, and <code>_links</code>:</p>

<pre><code>
    POST /imposters HTTP/1.1
    Host: localhost:2525
    Accept: application/json
    Content-Type: application/json

    {
      "protocol": "http",
      "port": 2526,
      "stubs": [
        {
          "responses": [
            {
              "proxyOnce": "http://real.api.com/",
              "is": {
                "statusCode": 200,
                "headers": {
                  "connection": "close",
                  "date": "Sat, 07 Dec 2013 20:19:51 GMT",
                  "transfer-encoding": "chunked"
                },
                "body": "PROXIED"
              }
            }
          ]
        }
      ]
    }
</code></pre>

<p>If you had predicates in your stub, they will also be present.</p>

<h3>Injections</h3>

<p>Asynchronous injection is supported through a third <code>callback</code> parameter.
If your function returns a value, the imposter will consider it as synchronous.  If
it does not return a value, it must call the <code>callback</code> parameter with the
response object.  The following injection takes advantage of the node.js environment
it will run in to proxy most of the request to www.google.com:</p>

<pre><code>
function (request, state, callback) {
    var http = require('http'),
        options = {
            method: request.method,
            hostname: 'www.google.com',
            port: 80,
            path: request.path,
            headers: request.headers
        },
        httpRequest = http.request(options, function (response) {
            response.body = '';
            response.setEncoding('utf8');
            response.on('data', function (chunk) {
                response.body += chunk;
            });
            response.on('end', function () {
                callback({
                    statusCode: response.statusCode,
                    headers: response.headers,
                    body: response.body
                });
            });
        });
    httpRequest.end();
    // No return value!!!
}
</code></pre>

<p>Though mountebank has gone to some trouble to make injections as hassle-free as
possible, there are a couple of gotchas.  First, when validating stub creation,
mountebank actually dry runs a sample request in a sandbox.  Normally, this is
side-effect free, as mountebank fakes out proxy calls and uses different state objects,
but he can make no guarantees with injections.  The <code>state</code> variable will
be untouched, but any environmental changes you make may persist to the actual stub
calls.</p>

<p>Second, injections may crash mountebank.  He's tried to protect himself, but
mountebank is not as clever as you are.  mountebank asks you to use other operators
when possible.  The example above would be both more robust and more powerful using
the <code>proxy</code> operator.  If you find yourself coding injections frequently
because of missing functionality that you believe would make a useful resolver,
mountebank humbly requests you to add a <a href='https://github.com/bbyars/mountebank/issues'>
feature request.</a></p>

<p>Finally, injections have access to mountebank's standard out and standard error streams.
<code>console.log</code> statements may prove invaluable to help troubleshoot misbehaving
injections.</p>

<% include ../../_footer %>
