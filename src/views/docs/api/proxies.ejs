<% include ../../_header %>

<h1>Proxies</h1>

<p>Proxies are one of the most powerful features of mountebank, surpassed only by the
mighty <a href='/docs/ap/injection'>injection.</a>  mountebank provides three different
kinds of behavior with proxies:</p>

<table>
  <tr>
    <th>Resolver</th>
    <th>Behavior</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>proxy</code></td>
    <td>standard</td>
    <td>Always proxies, which can be useful as the last stub in an imposter.  You
    can use <a href='/docs/api/predicates'>predicates</a> in a list of stubs, and
    add a standard proxy at the end of the list with no predicates as a fallback,
    taking advantage of the imposter's <em>first match</em> policy on stubs.  This
    is a bit like using a partial mock in a mocking library.</td>
  </tr>
  <tr>
    <td><code>proxyOnce</code></td>
    <td>simple record and playback</td>
    <td>Proxies the first time the resolver triggers, and remembers the response.
    Subsequent calls to the same stub will replay the recorded response.  You can
    save off the imposter's JSON representation and play it back on future test runs
    to avoid the proxy call entirely.</td>
  </tr>
  <tr>
    <td><code>proxyAll</code></td>
    <td>vary record and playback</td>
    <td>The <code>Vary</code> HTTP header allows intermediate proxies to conditionally
    serve a response from the cache based on another HTTP header.  Similarly, vary
    proxies allow a powerful form of record and playback, where the playback only
    happens if certain conditions are met.  Vary proxies allow you, for example, to
    create an imposter with a single stub containing the proxy, run a test suite,
    and save off the stub responses varying by <code>path</code>.  The next test
    run can use the saved imposter JSON representation without the remote service.
    Unlike every other stub resolver, vary proxies actually create new
    stubs.</td>
  </tr>
</table>

<p>All proxies take a <code>to</code> parameter.  For http and https imposters, that's
simply a URL.  For tcp imposters, it's an object containing a <code>host</code>
and <code>port</code>.</p>

<h2>Examples</h2>

<p>All of the examples below will proxy to the following origin server.  To help
us keep track of the imposters in the logs, we'll set the <code>name</code>
field.  We're using <a href='/docs/api/injection'>injection</a> to return the
path to the user.</p>

<pre><code data-test-id='proxy example'
           data-test-step='1'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 7575,
  "protocol": "http",
  "name": "origin",
  "stubs": [
    {
      "responses": [{
        "inject": "function (request) { return { body: 'hello from the origin at ' + request.path }; }"
      }]
    }
  ]
}
</code></pre>

<h3>Standard proxy</h3>

<p>We'll create an HTTP imposter that returns a stubbed response if the <code>path</code>
is <code>/test</code>, but proxy to the origin server in all other cases:</p>

<pre><code data-test-id='proxy example'
           data-test-step='2'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 6565,
  "protocol": "http",
  "name": "standard proxy",
  "stubs": [
    <strong class='highlight1'>{
      "predicates": {
        "path": { "is": "/test" }
      },
      "responses": [{ "is": { "body": "hello from the standard proxy" } }]
    }</strong>,<strong class='highlight2'>
    {
      "responses": [{ "proxy": { "to": "http://localhost:7575" }}]
    }</strong>
  ]
}
</code></pre>

<p>First let's test the stubbed response.</p>

<pre><code data-test-id='proxy example'
           data-test-step='3'
           data-test-type='http'>
GET <strong class='highlight1'>/test</strong> HTTP/1.1
Host: localhost:6565
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='3'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

<strong class='highlight1'>hello from the standard proxy</strong>
</code></pre>

<p>And now the proxy:</p>

<pre><code data-test-id='proxy example'
           data-test-step='4'
           data-test-type='http'>
GET <strong class='highlight2'>/</strong> HTTP/1.1
Host: localhost:6565
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='4'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

<strong class='highlight2'>hello from the origin at /</strong>
</code></pre>

<code class='hidden' data-test-id='proxy example'
                     data-test-step='5'
                     data-test-type='http'>
DELETE /imposters/6565 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
</code>

<h3>Simple record and playback proxy</h3>

<p>Let's create another imposter, this time using the <code>proxyOnce</code>
resolver to give us record and playback functionality.</p>

<pre><code data-test-id='proxy example'
           data-test-step='6'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 6566,
  "protocol": "http",
  "name": "proxyOnce",
  "stubs": [
    {
      "responses": [{ "proxyOnce": { "to": "http://localhost:7575" } }]
    }
  ]
}
</code></pre>

<p>The first call will trigger a call to the origin server:</p>

<pre><code data-test-id='proxy example'
           data-test-step='7'
           data-test-type='http'>
GET / HTTP/1.1
Host: localhost:6566
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='7'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

hello from the origin at /
</code></pre>

<p>The second call yields the same response without the remote call.
This is true even though the <code>path</code> is different,
proving that it did not hit the origin server.</p>

<pre><code data-test-id='proxy example'
           data-test-step='8'
           data-test-type='http'>
GET /test HTTP/1.1
Host: localhost:6566
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='8'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

hello from the origin at /
</code></pre>

<code class='hidden' data-test-id='proxy example'
                     data-test-step='9'
                     data-test-type='http'>
DELETE /imposters/6566 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
</code>

<h3>Vary record and playback proxy</h3>

<p>To get variable playback behavior, we'll use a <code>proxyAll</code>
resolver.</p>

<pre><code data-test-id='proxy example'
           data-test-step='10'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 6567,
  "protocol": "http",
  "name": "proxyAll",
  "stubs": [
    {
      "responses": [
        {
          "proxyAll": {
            "to": "http://localhost:7575",
            "remember": ["method", "path"]
          }
        }
      ]
    }
  ]
}
</code></pre>

<p>This imposter will create a new stub with an <code>is</code> resolver every time
it proxies, and put the new stub at the front of the <code>stubs</code> array.  It
will create stubs for each unique combination of <code>method</code> and
<code>path</code> that it sees.  This lets us solve the flaw in the
<code>proxyOnce</code> example above:</p>

<pre><code data-test-id='proxy example'
           data-test-step='11'
           data-test-type='http'>
GET / HTTP/1.1
Host: localhost:6567
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='11'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

hello from the origin at /
</code></pre>

<p>Unlike the simple record and playback example above, the second call
also calls the origin server, because of the different <code>path</code>.</p>

<pre><code data-test-id='proxy example'
           data-test-step='12'
           data-test-type='http'>
GET /test HTTP/1.1
Host: localhost:6567
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='12'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

hello from the origin at /test
</code></pre>

<p>The same call is replayed from a new stub, however:</p>

<pre><code data-test-id='proxy example'
           data-test-step='13'
           data-test-type='http'>
GET /test HTTP/1.1
Host: localhost:6567
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='13'
           data-test-ignore-lines='["^Date"]'>
HTTP/1.1 200 OK
Connection: close
Date: Thu, 09 Jan 2014 02:30:31 GMT
Transfer-Encoding: chunked

hello from the origin at /test
</code></pre>


<p>You can see the new stubs by issuing a <code>GET</code> to
the imposter.  You can save the response off and re-issue it next time
you create the imposter.</p>

<pre><code data-test-id='proxy example'
           data-test-step='14'
           data-test-type='http'>
GET /imposters/6567 HTTP/1.1
Host: localhost:<%= port %>
</code></pre>

<pre><code data-test-id='proxy example'
           data-test-verify-step='14'
           data-test-ignore-lines='["[Dd]ate", "requestFrom", "timestamp"]'>
HTTP/1.1 200 OK
Vary: Accept
Content-Type: application/json
Content-Length: 2666
Date: Sun, 12 Jan 2014 21:42:51 GMT
Connection: keep-alive

{
  "protocol": "http",
  "port": 6567,
  "name": "proxyAll",
  "requests": [
    {
      "requestFrom": "127.0.0.1:61798",
      "method": "GET",
      "path": "/",
      "query": {},
      "headers": {
        "accept": "application/json",
        "host": "localhost:6567",
        "connection": "close"
      },
      "body": ""
    },
    {
      "requestFrom": "127.0.0.1:61800",
      "method": "GET",
      "path": "/test",
      "query": {},
      "headers": {
        "accept": "application/json",
        "host": "localhost:6567",
        "connection": "close"
      },
      "body": ""
    },
    {
      "requestFrom": "127.0.0.1:61802",
      "method": "GET",
      "path": "/test",
      "query": {},
      "headers": {
        "accept": "application/json",
        "host": "localhost:6567",
        "connection": "keep-alive"
      },
      "body": ""
    }
  ],
  "stubs": [
    {
      "responses": [
        {
          "proxyAll": {
            "to": "http://localhost:7575",
            "remember": [
              "method",
              "path"
            ]
          }
        }
      ],
      "matches": [
        {
          "timestamp": "2014-01-12T21:42:51.533Z",
          "request": {
            "requestFrom": "127.0.0.1:61798",
            "method": "GET",
            "path": "/",
            "query": {},
            "headers": {
              "accept": "application/json",
              "host": "localhost:6567",
              "connection": "close"
            },
            "body": ""
          },
          "response": {
            "statusCode": 200,
            "headers": {
              "connection": "close",
              "date": "Sun, 12 Jan 2014 21:42:51 GMT",
              "transfer-encoding": "chunked"
            },
            "body": "hello from the origin at /"
          }
        },
        {
          "timestamp": "2014-01-12T21:42:51.538Z",
          "request": {
            "requestFrom": "127.0.0.1:61800",
            "method": "GET",
            "path": "/test",
            "query": {},
            "headers": {
              "accept": "application/json",
              "host": "localhost:6567",
              "connection": "close"
            },
            "body": ""
          },
          "response": {
            "statusCode": 200,
            "headers": {
              "connection": "close",
              "date": "Sun, 12 Jan 2014 21:42:51 GMT",
              "transfer-encoding": "chunked"
            },
            "body": "hello from the origin at /test"
          }
        }
      ]
    }
  ],
  "_links": {
    "self": {
      "href": "http://localhost:<%= port %>/imposters/6567"
    }
  }
}
</code></pre>

<code class='hidden' data-test-id='proxy example'
                     data-test-step='15'
                     data-test-type='http'>
DELETE /imposters/6567 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
</code>

<code class='hidden' data-test-id='proxy example'
                     data-test-step='16'
                     data-test-type='http'>
DELETE /imposters/7575 HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
</code>

<% include ../../_footer %>
