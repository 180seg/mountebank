<% include _header %>

      <h1>Documentation</h1>

      <h2>Command Line Options</h2>

      <p><code>npm install -g mountebank</code> will install a command line application called
      <code>mb</code>.  Running <code>mb</code> by itself will start up the API (and this site)
      on port 2525.  Effectively, it's the same as running
      <code>mb start --port 2525 --pidfile mb.pid</code>.  Here are the options described:</p>

      <table>
        <tr>
          <th>Option</th>
          <th>Description</th>
        <tr>
        <tr>
          <td><code><em>command</em></code></td>
          <td>One of <code>start</code>, <code>stop</code>, <code>restart</code>.  Defaults
          to <code>start</code>.</td>
        </tr>
        <tr>
          <td><code>--port 2525</code></td>
          <td>The port to run the main mountebank server on.  Defaults to 2525.</td>
        </tr>
        <tr>
          <td><code>--pidfile mb.pid</code></td>
          <td>mountebank stores the process id (PID) in a file, which is used by the stop and
          restart commands.  Defaults to mb.pid.  You would only specify this if you run two
          instances of <code>mb</code> from the same working directory, which is a niche
          requirement, but the mountebank build needs that capability.</td>
        </tr>
        <tr>
          <td><code>--allowInjection</code></td>
          <td>mountebank supports JavaScript injection for both predicates and stub responses,
          but they are disabled by default.  Including this parameter will enable injections,
          which are <code>eval</code>'d in.</td>
        </tr>
      </table>

      <h2>API</h2>

      <p>mountebank happily accepts your orders and delegates to his team of imposters.
      While you are free to parlay with mountebank through his RESTful API, his goal is
      to make you as comfortable as possible.  As you read this, his team of open source
      engineers are busy at work translating his API into your native language, and soon
      you will be able to converse with the imposters using a library that has adopted
      the idioms of mocking frameworks in your language.</p>

      <p>The API is Esperanto, designed to create an easy-to-learn, neutral language that
      transcends national borders and fosters peace and harmony.  mountebank loves your
      native language, but if you really want to understand mountebank, the API is
      described for your viewing pleasure.</p>

      <h3>Introduction</h3>

      <p>mountebank, being a man of the people, prefers the simple words of the vernacular over
      the silvery speech of the priesthood.  As if to prove the point, he speaks in a RESTful
      <code>application/json</code> rather than <code>application\vnd.mountebank+json</code>.
      While he does provide hypermedia, it is more as a convenience to you, with no professorial
      dictate that you follow the script provided.  To show how committed he is to that principle,
      all resources are described below.</p>

      <p>mountebank uses a basic set of HTTP status codes.  He knows that a 200 or 201 will
      make you happiest, but unfortunately he cannot guarantee that you will always receive
      one of those codes.  In the cases where the input you provide is malformed in some
      fashion, he will offer a humble apology for not being clear about what he needs, and
      respond with a 400.  In situations where you ask for a port that mountebank
      is unable to reserve, he will return you a 403.  Every effort has gone into providing response
      bodies to help you diagnose the problems.  Each error response returned will have a
      <code>code</code> and <code>message</code> at a minimum.  If extra information is available,
      mountebank will happily pass it to you.</p>

      <p>mountebank has made every effort to spare you from 5xx HTTP codes.  If you are
      unfortunate enough to receive one, first you should know that mountebank is most embarrassed.
      Please <a href='https://github.com/bbyars/mountebank/issues'>report</a>
      the issue, preferably with log details, and mountebank will help make it right for you.</p>

      <h3>Resources</h3>

      <h4>Home</h4>

      <ul>
        <li>URL template: <code>/</code></li>
        <li>HTTP verbs: <code>GET</code></li>
      </ul>

      <p>Unpretentious and welcoming, mirroring mountebank's simple good nature.  This endpoint
      exists for those who aspire to the RESTful
      <a href='http://martinfowler.com/articles/richardsonMaturityModel.html'>priesthood</a>,
      though they may be disappointed to find such a lowly language as <code>application/json</code>
      and the lack of URLs for relationships.  mountebank has no intention of forcing anybody to use
      this endpoint.

      <pre>
        GET / HTTP/1.1
        Host: localhost:2525
        Accept: application/json


        HTTP/1.1 200 OK
        Content-Type: application/json

        {
          "_links": {
            "imposters": {
              "href": "http://localhost:2525/imposters"
            }
          }
        }
      </pre>

      <h4>Imposters</h4>

      <ul>
        <li>URL template: <code>/imposters</code></li>
        <li>HTTP verbs: <code>GET, POST</code></li>
      </ul>

      <p>Though he's not proud to admit it, mountebank employs an army of imposters to
      fulfill your orders.  Because your needs are varied and sundry, his imposters
      are all different, and all are identified by a port number and associated with
      a protocol.  mountebank expects that you will be responsible for providing the
      port, as a convenience, of course, so that he doesn't grab a port that you
      expect to use in the near future for another important need.  And the protocol
      is all-important, as it describes which imposter to choose.  Of course,
      mountebank knows all protocols, but some he doesn't quite have ready just yet.
      Fortunately for you, his hordes of open source developers are working on it.</p>

      <p>The value you get out of mountebank always starts by creating an imposter.  If
      you don't need stubbing, then the port and protocol are all you need.</p>

      <pre>
        POST /imposters HTTP/1.1
        Host: localhost:2525
        Accept: application/json
        Content-Type: application/json

        {
          "port": 2526,
          "protocol": "HTTP"
        }


        HTTP/1.1 201 Created
        Location: http://localhost:2525/imposters/2526
        Content-Type: application/json

        {
          "protocol": "http",
          "port": 2526,
          "_links": {
            "_self": {
              "href": "http://localhost:2525/imposters/2526"
            }
          }
        }
      </pre>

      <p>You would also create any stubs in the post, although the stub content varies by protocol.
      At the moment, the only protocols supported are HTTP and HTTPS, which share the same
      <a href='/docs/protocols/http'>stub behavior</a>.</p>

      <p>Then you exercise your app under test, which depends on a web service configured to point
      to http://localhost:2526.  To retrieve a list of all imposters, simply issue a <code>GET</code>:</p>

      <pre>
        GET /imposters HTTP/1.1
        Host: localhost:2525
        Accept: application/json


        HTTP/1.1 200 OK
        Content-Type: application/json

        {
          "imposters": [
            {
              "protocol": "http",
              "port": 2526,
              "requests": [
                {
                  "path": "/test-request",
                  "method": "GET",
                  "headers": {
                    "host": "localhost:2526"
                  },
                  "body": ""
                }
              ],
              "stubs": [],
              "_links": {
                "self": {
                  "href": "/imposters/2526"
                }
              }
            }
          ]
        }
      </pre>

      <p>This is nothing more than an array of the content for a single imposter.</p>

      <h4>Imposter</h4>

      <ul>
        <li>URL template: <code>/imposters/{port}</code></li>
        <li>HTTP verbs: <code>GET, DELETE</code></li>
      </ul>

      <p>This resource is likely where you will do mock verifications that certain calls were
      made.  Both a <code>GET</code> and <code>DELETE</code> return the same body, but a
      <code>DELETE</code> frees up the port and removes the resource.  If you are concerned
      about optimizing the number of REST calls made during a test run, avoid the <code>GET</code>
      and get all the requests during the <code>DELETE</code> call:</p>

      <pre>
        GET /imposters HTTP/1.1
        Host: localhost:2525
        Accept: application/json


        HTTP/1.1 200 OK
        Content-Type: application/json

        {
          "protocol": "http",
          "port": 2526,
          "requests": [
            {
              "path": "/test-request",
              "method": "GET",
              "headers": {
                "host": "localhost:2526"
              },
              "body": ""
            }
          ],
          "stubs": [],
          "_links": {
            "self": {
              "href": "/imposters/2526"
            }
          }
        }
      </pre>

      <h3>Protocols</h3>

      <p>View more detailed information about each imposter by their protocol:</p>

      <ul>
        <li><a href='/docs/protocols/http'>http / https</a></li>
      </ul>

<% include _footer %>
